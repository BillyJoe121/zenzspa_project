# üìä AN√ÅLISIS: M√≥dulo Finances vs Documentaci√≥n Oficial de Wompi


PRUEBAS WOMPIIIIIIIIIIIIIIIIIIIIIIIII


**Fecha:** 2025-11-26
**Versi√≥n Wompi API:** 1.2.0 (OAS 3.0)
**Ambiente Actual:** Sandbox (Modo Pruebas)

---

## üéØ OBJETIVO DEL AN√ÅLISIS

Evaluar el estado actual del m√≥dulo `finances` y la centralizaci√≥n de pagos en el proyecto ZenzSpa, compar√°ndolo con la documentaci√≥n oficial de Wompi para identificar brechas de implementaci√≥n, caracter√≠sticas faltantes y oportunidades de mejora.

---

## üìö DOCUMENTACI√ìN OFICIAL DE WOMPI ANALIZADA

### **Endpoints Principales:**

#### **Transacciones**
- `GET /transactions/{transaction_id}` - Obtener una transacci√≥n
- `GET /transactions` - Buscar transacciones
- `POST /transactions` - **Crear una transacci√≥n**
- `POST /transactions/{transaction_id}/void` - Anular una transacci√≥n

#### **Tokenizaci√≥n**
- `POST /tokens/cards` - Tokenizar una tarjeta de cr√©dito
- `POST /tokens/nequi` - Tokenizar una cuenta de Nequi
- `GET /tokens/nequi/{token_id}` - Obtener informaci√≥n sobre una Cuenta de Nequi tokenizada

#### **Fuentes de Pago**
- `GET /payment_sources/{payment_source_id}` - Obtener una fuente de pago
- `POST /payment_sources` - Crear una fuente de pago

#### **Links de Pago**
- `GET /payment_links/{payment_link_id}` - Obtener un link de pago
- `PATCH /payment_links/{payment_link_id}` - Activa o desactiva un link de pago
- `POST /payment_links` - Crear un link de pago

#### **Comercios**
- `GET /merchants/{merchantPublicKey}` - Obtener un comercio y token de aceptaci√≥n

#### **PSE**
- `GET /pse/financial_institutions` - Listado de instituciones financieras de PSE

### **Llaves de Autenticaci√≥n (Modo Pruebas):**

```bash
# Ambiente Sandbox
WOMPI_BASE_URL=https://sandbox.wompi.co/v1

# Llaves P√∫blicas y Privadas
WOMPI_PUBLIC_KEY=pub_test_2Vkt6r1tIzdcOPnnv3w1gwdSN8FAJ759
WOMPI_PRIVATE_KEY=prv_test_tw0GsSicZrs32qkCgtApuTXfikozRXfp

# Secretos de Integraci√≥n
WOMPI_EVENT_SECRET=test_events_E1xGV2n5EzZJw67XtrQeK5bPMSVIgFS5
WOMPI_INTEGRITY_KEY=test_integrity_bhFKktEKLRGuiii3wUQH89pzrXGLvtDl
```

### **Ambiente de Producci√≥n:**

```bash
WOMPI_BASE_URL=https://production.wompi.co/v1

# Llaves con prefijos diferentes:
# - pub_prod_* para llave p√∫blica
# - prv_prod_* para llave privada
# - prod_events_* para eventos
# - prod_integrity_* para integridad
```

---

## ‚úÖ LO QUE YA EST√Å BIEN IMPLEMENTADO

### **1. Gateway Centralizado** ([finances/gateway.py](finances/gateway.py))

Tu implementaci√≥n **YA tiene un gateway centralizado** con 3 clientes especializados bien dise√±ados:

#### **1.1. WompiGateway (Consultas)** - L√≠neas 13-80

```python
class WompiGateway:
    """
    Cliente liviano para consultar transacciones en Wompi (charge-side).
    Centraliza timeouts, headers y un circuito simple para evitar cascadas.
    """
    REQUEST_TIMEOUT = 10
    _CIRCUIT_CACHE_KEY = "wompi:transactions:circuit"
```

**Caracter√≠sticas implementadas:**
- ‚úÖ Circuit breaker con Redis cache
- ‚úÖ Timeout configurable (10 segundos)
- ‚úÖ Manejo de errores con logging estructurado
- ‚úÖ M√©todo `fetch_transaction(reference)` para consultar transacciones
- ‚úÖ Headers con Bearer token authorization

**M√©todos disponibles:**
- `fetch_transaction(reference)` - Consulta transacci√≥n por ID/reference
- `_circuit_allows()` - Verifica si el circuito permite requests
- `_record_failure()` - Registra fallo y abre circuito si excede l√≠mite
- `_record_success()` - Cierra circuito en caso de √©xito

#### **1.2. WompiPaymentClient (Creaci√≥n de Transacciones)** - L√≠neas 94-191

```python
class WompiPaymentClient:
    """
    Cliente para crear transacciones en Wompi (cobros).
    Maneja circuit breaker simple y timeouts consistentes.
    """
    REQUEST_TIMEOUT = 15
    _CIRCUIT_CACHE_KEY = "wompi:payments:circuit"
```

**Caracter√≠sticas implementadas:**
- ‚úÖ Circuit breaker independiente para pagos
- ‚úÖ Timeout de 15 segundos (mayor que consultas)
- ‚úÖ M√©todo `create_transaction(payload)` gen√©rico
- ‚úÖ M√©todo `resolve_acceptance_token()` con cach√© (55 minutos)
- ‚úÖ Manejo de errores HTTP >=400 con circuit breaker

**M√©todos disponibles:**
- `create_transaction(payload)` - Crea transacci√≥n en Wompi
- `resolve_acceptance_token(base_url, public_key)` - Obtiene token de aceptaci√≥n
- Circuit breaker methods (compartidos con WompiGateway)

#### **1.3. WompiDisbursementClient (Dispersi√≥n de Fondos)** - [finances/services.py:33-141](finances/services.py:33-141)

```python
class WompiDisbursementClient:
    """
    Cliente sencillo para consultar saldo y ejecutar payouts en Wompi.
    Depende de las variables de entorno:
        - WOMPI_PAYOUT_PRIVATE_KEY
        - WOMPI_PAYOUT_BASE_URL
        - WOMPI_DEVELOPER_DESTINATION
    """
    REQUEST_TIMEOUT = 10
    _CIRCUIT_CACHE_KEY = "wompi:disbursement:circuit"
```

**Caracter√≠sticas implementadas:**
- ‚úÖ Circuit breaker para dispersiones
- ‚úÖ M√©todo `get_available_balance()` - Consulta balance en centavos
- ‚úÖ M√©todo `create_payout(amount)` - Crea dispersi√≥n a desarrollador
- ‚úÖ Manejo de m√∫ltiples formatos de respuesta (balanceInCents vs balance_in_cents)

**Endpoints utilizados:**
- `GET {base_url}/accounts` - Consulta balance disponible
- `POST {base_url}/transfers` - Crea dispersi√≥n/payout

### **2. Firma de Integridad** ([finances/gateway.py:82-91](finances/gateway.py:82-91))

```python
def build_integrity_signature(reference: str, amount_in_cents: int, currency: str) -> str | None:
    """
    Genera la firma de integridad para Wompi:
    SHA256("<reference><amount_in_cents><currency><INTEGRITY_KEY>")
    """
    integrity_key = getattr(settings, "WOMPI_INTEGRITY_KEY", None)
    if not integrity_key:
        return None
    concatenated = f"{reference}{amount_in_cents}{currency}{integrity_key}"
    return hashlib.sha256(concatenated.encode("utf-8")).hexdigest()
```

‚úÖ **Cumple con la documentaci√≥n oficial de Wompi (Paso 3)**

**Seg√∫n documentaci√≥n:**
```python
# Concatenaci√≥n correcta
"<Referencia><Monto><Moneda><SecretoIntegridad>"

# Ejemplo
"sk8-438k4-xmxm392-sn2m2490000COPprod_integrity_Z5mMke9x0k8gpErbDqwrJXMqsI6SFli6"

# SHA256
"37c8407747e595535433ef8f6a811d853cd943046624a0ec04662b17bbf33bf5"
```

‚úÖ **Tu implementaci√≥n sigue exactamente este algoritmo**

**Nota:** Si se usa `expiration-time`, debe agregarse a la concatenaci√≥n:
```
"<Referencia><Monto><Moneda><FechaExpiracion><SecretoIntegridad>"
```
‚ùå **FALTA implementar este caso opcional**

### **3. Variables de Entorno Configuradas** ([env.example.txt:99-112](env.example.txt:99-112))

```bash
# ----------------------------------------------------------------------------
# WOMPI (PAGOS)
# ----------------------------------------------------------------------------
WOMPI_BASE_URL=https://sandbox.wompi.co/v1
WOMPI_PUBLIC_KEY=pub_test_2Vkt6r1tIzdcOPnnv3w1gwdSN8FAJ759
WOMPI_PRIVATE_KEY=prv_test_tw0GsSicZrs32qkCgtApuTXfikozRXfp
WOMPI_INTEGRITY_SECRET=test_integrity_bhFKktEKLRGuiii3wUQH89pzrXGLvtDl
WOMPI_INTEGRITY_KEY=test_integrity_bhFKktEKLRGuiii3wUQH89pzrXGLvtDl
WOMPI_EVENT_SECRET=test_events_E1xGV2n5EzZJw67XtrQeK5bPMSVIgFS5
WOMPI_ACCEPTANCE_TOKEN=
# PRODUCCI√ìN: Debe usar https://
WOMPI_REDIRECT_URL=http://localhost:3000/payment-result
WOMPI_PAYOUT_PRIVATE_KEY=
WOMPI_PAYOUT_BASE_URL=
WOMPI_DEVELOPER_DESTINATION=
```

‚úÖ **Llaves correctas para modo pruebas** seg√∫n documentaci√≥n oficial

**Configuraci√≥n en [zenzspa/settings/base.py:401-413](zenzspa/settings/base.py:401-413):**
```python
WOMPI_PUBLIC_KEY = os.getenv("WOMPI_PUBLIC_KEY", "")
WOMPI_PRIVATE_KEY = os.getenv("WOMPI_PRIVATE_KEY", "")
WOMPI_INTEGRITY_SECRET = os.getenv("WOMPI_INTEGRITY_SECRET", "")
WOMPI_INTEGRITY_KEY = os.getenv("WOMPI_INTEGRITY_KEY", WOMPI_INTEGRITY_SECRET)
WOMPI_EVENT_SECRET = os.getenv("WOMPI_EVENT_SECRET", "")
WOMPI_BASE_URL = os.getenv("WOMPI_BASE_URL", "https://sandbox.wompi.co/v1")
WOMPI_ACCEPTANCE_TOKEN = os.getenv("WOMPI_ACCEPTANCE_TOKEN", "")
WOMPI_REDIRECT_URL = os.getenv("WOMPI_REDIRECT_URL", "http://localhost:3000/payment-result")
WOMPI_PAYOUT_PRIVATE_KEY = os.getenv("WOMPI_PAYOUT_PRIVATE_KEY", "")
WOMPI_PAYOUT_BASE_URL = os.getenv("WOMPI_PAYOUT_BASE_URL", "")
WOMPI_DEVELOPER_DESTINATION = os.getenv("WOMPI_DEVELOPER_DESTINATION", "")
```

‚úÖ **Validaci√≥n de HTTPS en producci√≥n:**
```python
# ZENZSPA-WOMPI-REDIRECT: Validar HTTPS en producci√≥n
if not DEBUG:
    if not WOMPI_REDIRECT_URL.startswith("https://"):
        raise ValueError(
            f"WOMPI_REDIRECT_URL debe usar https:// en producci√≥n. URL actual: {WOMPI_REDIRECT_URL}"
        )
```

### **4. Webhook Handler con Validaci√≥n de Firma** ([spa/services/payments.py:38-234](spa/services/payments.py:38-234))

```python
class WompiWebhookService:
    """
    Servicio para procesar y validar webhooks de Wompi.
    """

    def _validate_signature(self):
        """
        Valida la firma del evento para asegurar que proviene de Wompi.
        """
        if not all([self.data, self.sent_signature, self.timestamp]):
            logger.error("[PAYMENT-ALERT] Webhook Error: Firma o datos incompletos")
            raise ValueError("Firma o datos del webhook incompletos.")

        # El cuerpo del evento (data) debe ser convertido a un string JSON compacto.
        event_body_str = json.dumps(self.data, separators=(',', ':'))

        # La cadena a firmar es: body + timestamp + secreto_de_eventos
        concatenation = f"{event_body_str}{self.timestamp}{settings.WOMPI_EVENT_SECRET}"

        calculated_signature = hashlib.sha256(
            concatenation.encode('utf-8')).hexdigest()

        if not hashlib.sha256(self.sent_signature.encode('utf-8')).hexdigest() == hashlib.sha256(calculated_signature.encode('utf-8')).hexdigest():
            logger.error("[PAYMENT-ALERT] Webhook Error: Firma inv√°lida")
            raise ValueError("Firma del webhook inv√°lida. La petici√≥n podr√≠a ser fraudulenta.")
```

‚úÖ **Implementa validaci√≥n de seguridad**
‚ö†Ô∏è **PERO no sigue exactamente el algoritmo oficial** (ver Brecha #5)

### **5. Modelo de Pagos Robusto** ([spa/models/payment.py](spa/models/payment.py))

```python
class Payment(BaseModel):
    class PaymentStatus(models.TextChoices):
        PENDING = 'PENDING', 'Pendiente'
        APPROVED = 'APPROVED', 'Aprobado'
        DECLINED = 'DECLINED', 'Declinado'
        ERROR = 'ERROR', 'Error'
        TIMEOUT = 'TIMEOUT', 'Sin confirmaci√≥n'
        PAID_WITH_CREDIT = 'PAID_WITH_CREDIT', 'Pagado con Saldo a Favor'

    class PaymentType(models.TextChoices):
        ADVANCE = 'ADVANCE', 'Anticipo de Cita'
        FINAL = 'FINAL', 'Pago Final de Cita'
        PACKAGE = 'PACKAGE', 'Compra de Paquete'
        TIP = 'TIP', 'Propina'
        VIP_SUBSCRIPTION = 'VIP_SUBSCRIPTION', 'Membres√≠a VIP'
        ORDER = 'ORDER', 'Orden de Marketplace'
```

‚úÖ **Estados alineados con Wompi:** PENDING, APPROVED, DECLINED, ERROR
‚úÖ **Soporte para m√∫ltiples tipos de pago**
‚úÖ **Almacena `transaction_id` y `raw_response`** para reconciliaci√≥n

### **6. Servicio de Comisiones de Desarrollador** ([finances/services.py:143-341](finances/services.py:143-341))

```python
class DeveloperCommissionService:
    """
    Orquesta el registro de comisiones, c√°lculo de deuda y pagos al desarrollador.
    """

    @classmethod
    @transaction.atomic
    def register_commission(cls, payment):
        """Registra comisi√≥n por pago exitoso"""

    @staticmethod
    def get_developer_debt(include_failed: bool = True) -> Decimal:
        """Calcula deuda pendiente con desarrollador"""

    @classmethod
    def evaluate_payout(cls):
        """Eval√∫a si procede dispersi√≥n autom√°tica"""

    @classmethod
    def _attempt_payout(cls, settings_obj, current_debt: Decimal):
        """Ejecuta dispersi√≥n usando WompiDisbursementClient"""
```

‚úÖ **Integraci√≥n completa con Wompi Payouts**
‚úÖ **Manejo de estados:** PENDING, PAID, FAILED_NSF
‚úÖ **Circuit breaker para evitar fallos en cascada**

### **7. Modelo de Comisiones con Validaciones** ([finances/models.py](finances/models.py))

```python
class CommissionLedger(BaseModel):
    class Status(models.TextChoices):
        PENDING = "PENDING", "Pendiente"
        PAID = "PAID", "Pagada"
        FAILED_NSF = "FAILED_NSF", "Fondos insuficientes"

    amount = models.DecimalField(max_digits=12, decimal_places=2)
    paid_amount = models.DecimalField(max_digits=12, decimal_places=2, default=Decimal("0.00"))
    wompi_transfer_id = models.CharField(max_length=255, blank=True, null=True)

    def clean(self):
        super().clean()
        if self.amount is not None and self.amount < Decimal("0"):
            raise ValidationError({"amount": "El monto de la comisi√≥n no puede ser negativo."})
        if self.paid_amount is not None and self.paid_amount < Decimal("0"):
            raise ValidationError({"paid_amount": "El monto pagado no puede ser negativo."})

    def save(self, *args, **kwargs):
        # Normalizar a 2 decimales
        if self.amount is not None:
            self.amount = self.amount.quantize(Decimal("0.01"))
        if self.paid_amount is not None:
            self.paid_amount = self.paid_amount.quantize(Decimal("0.01"))
        self.full_clean()
        return super().save(*args, **kwargs)
```

‚úÖ **Normalizaci√≥n autom√°tica de decimales**
‚úÖ **Validaciones robustas**
‚úÖ **Trazabilidad con `wompi_transfer_id`**

---

## üî¥ BRECHAS CR√çTICAS vs DOCUMENTACI√ìN DE WOMPI

### **BRECHA #1: Falta Implementar M√©todos de Pago Espec√≠ficos**

**Seg√∫n la documentaci√≥n oficial de Wompi, los m√©todos de pago soportados son:**

| M√©todo de Pago | Estado Actual | Implementaci√≥n Requerida | Prioridad |
|----------------|---------------|--------------------------|-----------|
| **CARD** (Tarjeta) | ‚ö†Ô∏è Soportado parcialmente | Agregar tokenizaci√≥n con `POST /tokens/cards` | üü° Media |
| **NEQUI** | ‚ö†Ô∏è Mencionado en tests | Implementar flujo completo con `POST /tokens/nequi` | üî¥ Alta |
| **PSE** | ‚ùå **NO IMPLEMENTADO** | **CR√çTICO - Es el m√©todo m√°s usado en Colombia** | üî¥ **CR√çTICA** |
| **BANCOLOMBIA_TRANSFER** | ‚ùå **NO IMPLEMENTADO** | Implementar con `async_payment_url` | üü° Media |
| **BANCOLOMBIA_QR** | ‚ùå **NO IMPLEMENTADO** | Implementar con `sandbox_status` | üü¢ Baja |
| **DAVIPLATA** | ‚ùå **NO IMPLEMENTADO** | Implementar con OTP | üü° Media |
| **BNPL Bancolombia** | ‚ùå **NO IMPLEMENTADO** | Implementar Buy Now Pay Later | üü¢ Baja |
| **Puntos Colombia** | ‚ùå **NO IMPLEMENTADO** | Implementar programa de puntos | üü¢ Baja |

#### **Evidencia en el c√≥digo actual:**

**spa/services/payments.py:341-482** - Solo hay cobro recurrente gen√©rico:
```python
@classmethod
def charge_recurrence_token(cls, user, amount, token):
    """
    Ejecuta un cobro recurrente usando una fuente de pago (payment_source_id)
    previamente creada en Wompi (Cards, Nequi, Daviplata, Bancolombia, etc.).

    Retorna:
        (Payment.PaymentStatus, transaction_payload (dict), reference (str))
    """
    # ...
    payload = {
        "amount_in_cents": amount_in_cents,
        "currency": currency,
        "customer_email": customer_email,
        "reference": reference,
        "payment_source_id": payment_source_id,  # ‚ö†Ô∏è ¬øCard? ¬øNequi? ¬øDaviplata?
        "recurrent": True,
    }
```

‚ùå **Problema:** No especifica el tipo de m√©todo de pago ni maneja flujos espec√≠ficos

#### **Datos de Prueba en Sandbox (Documentaci√≥n Oficial):**

**Tarjetas:**
```
4242 4242 4242 4242 ‚Üí APPROVED
4111 1111 1111 1111 ‚Üí DECLINED
Cualquier otra ‚Üí ERROR
```

**Nequi:**
```
3991111111 ‚Üí APPROVED
3992222222 ‚Üí DECLINED
Cualquier otro ‚Üí ERROR
```

**PSE:**
```python
{
  "payment_method": {
    "type": "PSE",
    "user_type": 0,  # 0=natural, 1=jur√≠dica
    "user_legal_id_type": "CC",  # CC o NIT
    "user_legal_id": "1999888777",
    "financial_institution_code": "1",  # "1"=APPROVED, "2"=DECLINED
    "payment_description": "Pago a Tienda Wompi"  # Max 30 caracteres
  }
}
```

**Bancolombia Transfer:**
```python
{
  "payment_method": {
    "type": "BANCOLOMBIA_TRANSFER",
    "payment_description": "Pago a Tienda Wompi"  # Max 64 caracteres
  }
}
# Luego usar data.payment_method.async_payment_url para autenticaci√≥n
```

**Daviplata:**
```python
{
  "payment_method": {
    "type": "DAVIPLATA",
    "phone_number": "3991111111"  # Para APPROVED en sandbox
  }
}
# OTPs para pruebas:
# 574829 ‚Üí APPROVED
# 932015 ‚Üí DECLINED
# 186743 ‚Üí DECLINED sin saldo
# 999999 ‚Üí ERROR
```

### **BRECHA #2: Falta Endpoint POST /transactions para Pagos Manuales**

**Documentaci√≥n Wompi (Swagger):**
```
POST /transactions
Crear una transacci√≥n

Body:
{
  "amount_in_cents": 2490000,
  "currency": "COP",
  "customer_email": "example@email.com",
  "reference": "unique-reference-123",
  "payment_method": {
    "type": "PSE",
    "user_type": 0,
    "user_legal_id_type": "CC",
    "user_legal_id": "1234567890",
    "financial_institution_code": "1",
    "payment_description": "Pago de servicios"
  },
  "signature": {
    "integrity": "37c8407747e595535433ef8f6a811d853cd943046624a0ec04662b17bbf33bf5"
  }
}
```

**Tu c√≥digo actual:**

‚úÖ **S√≠ usa `WompiPaymentClient.create_transaction()`** ([finances/gateway.py:137-164](finances/gateway.py:137-164))

‚ùå **PERO solo se usa para cobros recurrentes VIP** ([spa/services/payments.py:428-430](spa/services/payments.py:428-430)):
```python
client = WompiPaymentClient(base_url=base_url, private_key=private_key)
try:
    response_data, status_code = client.create_transaction(payload)
except requests.RequestException as exc:
    logger.exception("Error comunic√°ndose con Wompi al intentar renovar VIP")
```

‚ùå **NO se usa para:**
- Pagos con PSE
- Pagos con Nequi
- Pagos con Bancolombia
- Pagos con Daviplata
- Pagos manuales de citas/servicios
- Pagos de √≥rdenes del marketplace

**Evidencia:** El marketplace y spa dependen 100% del Widget de Wompi en el frontend:

**marketplace/views.py:281-286:**
```python
return Response({
    'publicKey': settings.WOMPI_PUBLIC_KEY,
    'currency': getattr(settings, "WOMPI_CURRENCY", "COP"),
    'amountInCents': amount_in_cents,
    'reference': reference,
    'signature': signature,
    'redirectUrl': settings.WOMPI_REDIRECT_URL,
    'acceptanceToken': acceptance_token,
}, status=status.HTTP_200_OK)
```

### **BRECHA #3: Falta Tokenizaci√≥n de Tarjetas y Nequi**

**Documentaci√≥n Wompi:**

#### **Tokenizar Tarjeta:**
```
POST /tokens/cards
{
  "number": "4242424242424242",
  "cvc": "123",
  "exp_month": "12",
  "exp_year": "25",
  "card_holder": "Juan Perez"
}

Response:
{
  "status": "CREATED",
  "data": {
    "id": "tok_prod_123456_abcdef"
  }
}
```

#### **Tokenizar Nequi:**
```
POST /tokens/nequi
{
  "phone_number": "3991111111"
}

Response:
{
  "status": "PENDING",
  "data": {
    "id": "tok_nequi_123456"
  }
}
```

**Tu c√≥digo actual:**

‚ùå **El backend NO tokeniza** - Depende 100% del Widget de Wompi en el frontend

**Evidencia:**

**marketplace/views.py:281** - Solo pasa `publicKey` al frontend:
```python
'publicKey': settings.WOMPI_PUBLIC_KEY,
```

**spa/services/payments.py:341-370** - Recibe `token` ya tokenizado:
```python
def charge_recurrence_token(cls, user, amount, token):
    # Asume que el token ya fue creado externamente
    try:
        if isinstance(token, str):
            token_str = token.strip()
            if not token_str:
                raise ValueError("El token de pago es obligatorio")
            payment_source_id = int(token_str)
    except (TypeError, ValueError):
        raise ValueError(
            "El token de cobro recurrente debe ser el ID num√©rico de la fuente de pago (payment_source_id)."
        )
```

**Problema:** No hay endpoint backend para tokenizar desde el servidor, solo se acepta `payment_source_id` num√©rico ya existente.

### **BRECHA #4: Par√°metros Faltantes en Transacciones**

**Documentaci√≥n Wompi (Par√°metros opcionales):**

```javascript
// Widget Integration
<script
  src="https://checkout.wompi.co/widget.js"
  data-render="button"
  data-public-key="pub_test_..."
  data-currency="COP"
  data-amount-in-cents="7890000"
  data-reference="37DNKF84S92N1S"
  data-signature:integrity="37c8407747e595535433ef8f6a811d853cd943046624a0ec04662b17bbf33bf5"
  data-redirect-url="https://transaction-redirect.wompi.co/check"
  data-expiration-time="2023-06-09T20:28:50.000Z"

  // TAX INFORMATION (FALTA IMPLEMENTAR)
  data-tax-in-cents:consumption="590000"
  data-tax-in-cents:vat="1290000"

  // CUSTOMER DATA (FALTA IMPLEMENTAR)
  data-customer-data:email="lola@perez.com"
  data-customer-data:full-name="Lola Perez"
  data-customer-data:phone-number="3019777777"
  data-customer-data:phone-number-prefix="+57"
  data-customer-data:legal-id="123456789"
  data-customer-data:legal-id-type="CC"

  // SHIPPING ADDRESS (PARCIALMENTE IMPLEMENTADO)
  data-shipping-address:address-line-1="Carrera 123 # 4-5"
  data-shipping-address:address-line-2="apto 123"
  data-shipping-address:country="CO"
  data-shipping-address:city="Bogota"
  data-shipping-address:phone-number="3019988888"
  data-shipping-address:region="Cundinamarca"
  data-shipping-address:name="Pedro Perez"
></script>
```

**API Integration (POST /transactions):**
```json
{
  "amount_in_cents": 7890000,
  "currency": "COP",
  "reference": "37DNKF84S92N1S",
  "customer_email": "lola@perez.com",
  "signature": {
    "integrity": "37c8407747e595535433ef8f6a811d853cd943046624a0ec04662b17bbf33bf5"
  },

  // ‚ùå FALTA: TAX INFORMATION
  "tax_in_cents": {
    "vat": 1290000,
    "consumption": 590000
  },

  // ‚ùå FALTA: CUSTOMER DATA
  "customer_data": {
    "email": "lola@perez.com",
    "full_name": "Lola Perez",
    "phone_number": "3019777777",
    "phone_number_prefix": "+57",
    "legal_id": "123456789",
    "legal_id_type": "CC"
  },

  // ‚ö†Ô∏è PARCIAL: SHIPPING ADDRESS
  "shipping_address": {
    "address_line_1": "Carrera 123 # 4-5",
    "address_line_2": "apto 123",
    "country": "CO",
    "city": "Bogota",
    "phone_number": "3019988888",
    "region": "Cundinamarca",
    "name": "Pedro Perez"
  },

  // ‚ùå FALTA: PAYMENT METHOD (para PSE/Nequi/etc)
  "payment_method": {
    "type": "PSE",
    "user_type": 0,
    "user_legal_id_type": "CC",
    "user_legal_id": "1234567890",
    "financial_institution_code": "1",
    "payment_description": "Pago de servicios"
  }
}
```

**Tu c√≥digo actual:**

‚úÖ **S√ç tienes modelo Payment con campos b√°sicos**
‚ùå **FALTAN campos:**
- `tax_in_cents` (VAT, CONSUMPTION)
- `customer_data` (legal_id, legal_id_type)
- `payment_method` (tipo espec√≠fico, datos del m√©todo)

**Evidencia:**

**spa/models/payment.py** - No incluye estos campos:
```python
class Payment(BaseModel):
    user = models.ForeignKey(...)
    appointment = models.ForeignKey(...)
    order = models.ForeignKey(...)
    amount = models.DecimalField(...)
    status = models.CharField(...)
    payment_type = models.CharField(...)
    transaction_id = models.CharField(...)
    raw_response = models.JSONField(...)
    used_credit = models.ForeignKey(...)

    # ‚ùå FALTAN:
    # tax_vat_in_cents = ...
    # tax_consumption_in_cents = ...
    # customer_legal_id = ...
    # customer_legal_id_type = ...
    # payment_method_type = ...  # PSE, NEQUI, CARD, etc.
    # payment_method_data = JSONField(...)
```

**Nota de Wompi (Documentaci√≥n):**
> "Es importante resaltar que los impuestos enviados en el objeto `taxes` no se sumar√°n al total de la transacci√≥n. Por ejemplo, en una transacci√≥n cuyo total (`amount_in_cents`) es de COP$119,000 y cuyo IVA es de COP$19,000, este √∫ltimo monto ya hace parte del total, implicando entonces que: la base sin impuestos ($100,000) + el IVA ($19,000) = el total ($119,000)."

### **BRECHA #5: Validaci√≥n de Webhooks NO Sigue Algoritmo Oficial**

**Documentaci√≥n Wompi (Seguridad de Eventos):**

```python
# Paso 1: Concatenar valores de properties especificadas
signature = {
  "properties": [
    "transaction.id",
    "transaction.status",
    "transaction.amount_in_cents"
  ],
  "checksum": "3476DDA50F64CD7CBD160689640506FEBEA93239BC524FC0469B2C68A3CC8BD0"
}

# Extraer valores seg√∫n properties
transaction.id = "1234-1610641025-49201"
transaction.status = "APPROVED"
transaction.amount_in_cents = 4490000

# Concatenar EN ORDEN
concatenated = "1234-1610641025-49201APPROVED4490000"

# Paso 2: Agregar timestamp
concatenated += "1530291411"  # timestamp del evento
# Resultado: "1234-1610641025-49201APPROVED44900001530291411"

# Paso 3: Agregar secreto
concatenated += "prod_events_OcHnIzeBl5socpwByQ4hA52Em3USQ93Z"
# Resultado: "1234-1610641025-49201APPROVED44900001530291411prod_events_OcHnIzeBl5socpwByQ4hA52Em3USQ93Z"

# Paso 4: SHA256
checksum = hashlib.sha256(concatenated.encode()).hexdigest()
# "3476DDA50F64CD7CBD160689640506FEBEA93239BC524FC0469B2C68A3CC8BD0"

# Paso 5: Comparar con signature.checksum
if checksum == signature["checksum"]:
    print("Webhook v√°lido")
```

**Tu c√≥digo actual:** ([spa/services/payments.py:64-87](spa/services/payments.py:64-87))

```python
def _validate_signature(self):
    """
    Valida la firma del evento para asegurar que proviene de Wompi.
    """
    if not all([self.data, self.sent_signature, self.timestamp]):
        logger.error("[PAYMENT-ALERT] Webhook Error: Firma o datos incompletos")
        raise ValueError("Firma o datos del webhook incompletos.")

    # ‚ö†Ô∏è PROBLEMA: Usa json.dumps(data) en lugar de properties espec√≠ficas
    event_body_str = json.dumps(self.data, separators=(',', ':'))

    # La cadena a firmar es: body + timestamp + secreto_de_eventos
    concatenation = f"{event_body_str}{self.timestamp}{settings.WOMPI_EVENT_SECRET}"

    calculated_signature = hashlib.sha256(
        concatenation.encode('utf-8')).hexdigest()

    # ‚ö†Ô∏è Comparaci√≥n doble SHA256 innecesaria
    if not hashlib.sha256(self.sent_signature.encode('utf-8')).hexdigest() == hashlib.sha256(calculated_signature.encode('utf-8')).hexdigest():
        logger.error("[PAYMENT-ALERT] Webhook Error: Firma inv√°lida")
        raise ValueError("Firma del webhook inv√°lida. La petici√≥n podr√≠a ser fraudulenta.")
```

‚ùå **Problemas identificados:**

1. **NO usa `signature.properties`** - Deber√≠a extraer solo los campos especificados en el array `properties`, no todo el objeto `data`
2. **JSON completo vs valores espec√≠ficos** - Wompi NO serializa todo el JSON, solo concatena valores espec√≠ficos
3. **Comparaci√≥n doble SHA256** - Innecesaria, debe comparar directamente los hexdigest

**Riesgo:** Si Wompi cambia el orden de campos en el JSON del webhook, tu validaci√≥n fallar√° aunque sea leg√≠tima.

### **BRECHA #6: Falta Endpoint GET /pse/financial_institutions**

**Documentaci√≥n Wompi:**
```
GET /pse/financial_institutions

Response:
{
  "data": [
    {
      "financial_institution_code": "1",
      "financial_institution_name": "Banco de Bogot√°"
    },
    {
      "financial_institution_code": "2",
      "financial_institution_name": "Banco Popular"
    }
  ]
}
```

‚ùå **Tu c√≥digo NO implementa este endpoint**

**Necesidad:** Para mostrar lista de bancos al usuario antes de crear transacci√≥n PSE.

### **BRECHA #7: Falta Manejo de Async Payment URLs**

**Documentaci√≥n Wompi (Bancolombia Transfer):**

```python
# Paso 1: Crear transacci√≥n
response = create_transaction({
  "payment_method": {
    "type": "BANCOLOMBIA_TRANSFER",
    "payment_description": "Pago a Tienda"
  }
})

# Paso 2: Obtener URL de autenticaci√≥n
auth_url = response["data"]["payment_method"]["async_payment_url"]

# Paso 3: Redirigir usuario a auth_url
# El usuario completa autenticaci√≥n en p√°gina de Bancolombia

# Paso 4: Webhook notifica resultado final
```

‚ùå **Tu c√≥digo NO maneja `async_payment_url`**

**Evidencia:** ([spa/services/payments.py:95-234](spa/services/payments.py:95-234))
```python
def process_transaction_update(self):
    transaction_data = self.data.get("transaction", {})
    transaction_status = transaction_data.get("status")
    # ... procesa status pero no maneja payment_method.async_payment_url
```

### **BRECHA #8: Falta Validaci√≥n de Expiration Time**

**Documentaci√≥n Wompi:**
```javascript
data-expiration-time="2023-06-09T20:28:50.000Z"
```

Si se usa `expiration-time`, la firma de integridad debe incluirlo:
```python
concatenated = f"{reference}{amount_in_cents}{currency}{expiration_time}{integrity_key}"
```

‚ùå **Tu funci√≥n `build_integrity_signature`** ([finances/gateway.py:82-91](finances/gateway.py:82-91)) **NO acepta `expiration_time`:**

```python
def build_integrity_signature(reference: str, amount_in_cents: int, currency: str) -> str | None:
    # ‚ùå Falta par√°metro expiration_time
    concatenated = f"{reference}{amount_in_cents}{currency}{integrity_key}"
    return hashlib.sha256(concatenated.encode("utf-8")).hexdigest()
```

---

## üìã ESTADO DE CENTRALIZACI√ìN DE PAGOS

### **M√≥dulos con L√≥gica de Pagos:**

| M√≥dulo | Integraci√≥n Wompi | Estado Centralizaci√≥n | Duplicaci√≥n |
|--------|-------------------|-----------------------|-------------|
| **finances** | ‚úÖ Gateway completo (3 clientes) | ‚úÖ **100% centralizado** | ‚ùå Ninguna |
| **spa** | ‚ö†Ô∏è Usa `finances.gateway` pero tiene l√≥gica propia de webhooks | üü° **70% centralizado** | ‚ö†Ô∏è Webhook handler propio |
| **marketplace** | ‚ö†Ô∏è Duplica l√≥gica de obtenci√≥n de acceptance token | üî¥ **40% centralizado** | üî¥ Duplica `resolve_acceptance_token` |

### **An√°lisis Detallado de Duplicaci√≥n:**

#### **1. marketplace/views.py:248-286** - Duplica Obtenci√≥n de Acceptance Token

```python
# L√çNEA 248-250: Genera reference y firma (‚úÖ CORRECTO)
reference = f"ORDER-{order.id}-{uuid.uuid4().hex[:8]}"
order.wompi_transaction_id = reference
order.save(update_fields=['wompi_transaction_id', 'updated_at'])

# L√çNEA 252-257: üî¥ DUPLICA l√≥gica de WompiPaymentClient.resolve_acceptance_token
base_url = getattr(settings, "WOMPI_BASE_URL", PaymentService.WOMPI_DEFAULT_BASE_URL)
try:
    acceptance_token = PaymentService._resolve_acceptance_token(base_url)
except requests.Timeout:
    logger.error("Timeout al obtener acceptance token de Wompi")
    # ...manejo de errores duplicado

# L√çNEA 266-272: üî¥ DUPLICA build_integrity_signature
signature = PaymentService._build_integrity_signature(
    reference=reference,
    amount_in_cents=amount_in_cents,
    currency=getattr(settings, "WOMPI_CURRENCY", "COP"),
)
```

**Deber√≠a ser:**
```python
from finances.gateway import WompiPaymentClient, build_integrity_signature

# Obtener token usando gateway centralizado
acceptance_token = WompiPaymentClient.resolve_acceptance_token()

# Generar firma usando funci√≥n centralizada
signature = build_integrity_signature(
    reference=reference,
    amount_in_cents=amount_in_cents,
    currency=getattr(settings, "WOMPI_CURRENCY", "COP"),
)
```

#### **2. spa/services/payments.py:341-482** - Duplica Creaci√≥n de Transacciones

```python
# L√çNEA 428-430: üü° USA WompiPaymentClient CORRECTAMENTE
client = WompiPaymentClient(base_url=base_url, private_key=private_key)
try:
    response_data, status_code = client.create_transaction(payload)
```

‚úÖ **Esto est√° bien** - Usa el gateway centralizado

‚ùå **PERO** solo se usa para cobros recurrentes VIP, no para pagos generales

#### **3. spa/services/payments.py:38-234** - Webhook Handler Propio

```python
class WompiWebhookService:
    """
    Servicio para procesar y validar webhooks de Wompi.
    """
    def _validate_signature(self):
        # ... validaci√≥n propia (no usa finances.gateway)

    def process_transaction_update(self):
        # ... procesamiento propio
```

‚ö†Ô∏è **Deber√≠a estar en `finances` module** para verdadera centralizaci√≥n

---

## üõ†Ô∏è PLAN DE ACCI√ìN RECOMENDADO

### **Fase 1: Completar M√©todos de Pago** (CR√çTICO) üî¥

#### **1.1. Implementar PSE** (M√°s usado en Colombia)

**Archivo:** [finances/gateway.py](finances/gateway.py)

```python
class WompiPaymentClient:
    # ... m√©todos existentes ...

    def create_pse_transaction(
        self,
        *,
        amount_in_cents: int,
        reference: str,
        customer_email: str,
        user_type: int,  # 0=natural, 1=jur√≠dica
        user_legal_id: str,
        user_legal_id_type: str,  # CC, NIT, CE, etc.
        financial_institution_code: str,
        payment_description: str,  # Max 30 caracteres
        redirect_url: str | None = None,
    ):
        """
        Crea una transacci√≥n PSE en Wompi.

        Args:
            amount_in_cents: Monto en centavos
            reference: Referencia √∫nica de pago
            customer_email: Email del pagador
            user_type: 0=Persona Natural, 1=Persona Jur√≠dica
            user_legal_id: N√∫mero de documento
            user_legal_id_type: Tipo de documento (CC, NIT, CE, PP, TI, DNI, RG, OTHER)
            financial_institution_code: C√≥digo del banco PSE
            payment_description: Descripci√≥n del pago (max 30 caracteres)
            redirect_url: URL de redirecci√≥n opcional

        Returns:
            (dict, int): Response data y status code

        Raises:
            ValueError: Si payment_description excede 30 caracteres
            requests.RequestException: Si falla la comunicaci√≥n con Wompi
        """
        if len(payment_description) > 30:
            raise ValueError("payment_description debe tener m√°ximo 30 caracteres")

        currency = getattr(settings, "WOMPI_CURRENCY", "COP")

        # Generar firma de integridad
        signature = build_integrity_signature(
            reference=reference,
            amount_in_cents=amount_in_cents,
            currency=currency,
        )

        payload = {
            "amount_in_cents": amount_in_cents,
            "currency": currency,
            "customer_email": customer_email,
            "reference": reference,
            "payment_method": {
                "type": "PSE",
                "user_type": user_type,
                "user_legal_id_type": user_legal_id_type,
                "user_legal_id": user_legal_id,
                "financial_institution_code": financial_institution_code,
                "payment_description": payment_description,
            },
        }

        if signature:
            payload["signature"] = {"integrity": signature}

        if redirect_url:
            payload["redirect_url"] = redirect_url

        return self.create_transaction(payload)

    def get_pse_financial_institutions(self):
        """
        Obtiene la lista de instituciones financieras disponibles para PSE.

        Returns:
            list: Lista de bancos con c√≥digo y nombre

        Example:
            [
                {"financial_institution_code": "1", "financial_institution_name": "Banco de Bogot√°"},
                {"financial_institution_code": "2", "financial_institution_name": "Banco Popular"}
            ]
        """
        if not self.base_url:
            raise ValueError("WOMPI_BASE_URL no configurada")

        url = f"{self.base_url.rstrip('/')}/pse/financial_institutions"

        try:
            response = requests.get(url, timeout=self.REQUEST_TIMEOUT)
            response.raise_for_status()
            data = response.json()
            return data.get("data", [])
        except requests.Timeout:
            logger.error("Timeout al obtener instituciones financieras PSE")
            raise
        except requests.RequestException as exc:
            logger.exception("Error al obtener instituciones financieras PSE: %s", exc)
            raise
```

**Datos de Prueba en Sandbox:**
```python
# Para APPROVED
financial_institution_code = "1"

# Para DECLINED
financial_institution_code = "2"
```

#### **1.2. Implementar Nequi**

```python
class WompiPaymentClient:
    # ... m√©todos existentes ...

    def create_nequi_transaction(
        self,
        *,
        amount_in_cents: int,
        reference: str,
        customer_email: str,
        phone_number: str,
        redirect_url: str | None = None,
    ):
        """
        Crea una transacci√≥n Nequi en Wompi.

        Args:
            amount_in_cents: Monto en centavos
            reference: Referencia √∫nica de pago
            customer_email: Email del pagador
            phone_number: N√∫mero de celular Nequi (10 d√≠gitos)
            redirect_url: URL de redirecci√≥n opcional

        Returns:
            (dict, int): Response data y status code

        Example (Sandbox):
            phone_number="3991111111"  # APPROVED
            phone_number="3992222222"  # DECLINED
            phone_number="cualquier_otro"  # ERROR
        """
        currency = getattr(settings, "WOMPI_CURRENCY", "COP")

        signature = build_integrity_signature(
            reference=reference,
            amount_in_cents=amount_in_cents,
            currency=currency,
        )

        payload = {
            "amount_in_cents": amount_in_cents,
            "currency": currency,
            "customer_email": customer_email,
            "reference": reference,
            "payment_method": {
                "type": "NEQUI",
                "phone_number": phone_number,
            },
        }

        if signature:
            payload["signature"] = {"integrity": signature}

        if redirect_url:
            payload["redirect_url"] = redirect_url

        return self.create_transaction(payload)

    def tokenize_nequi(self, phone_number: str):
        """
        Tokeniza una cuenta Nequi para cobros recurrentes.

        Args:
            phone_number: N√∫mero de celular Nequi (10 d√≠gitos)

        Returns:
            dict: Token de Nequi

        Example:
            {
                "status": "PENDING",
                "data": {
                    "id": "tok_nequi_123456"
                }
            }
        """
        if not self.base_url:
            raise ValueError("WOMPI_BASE_URL no configurada")

        url = f"{self.base_url.rstrip('/')}/tokens/nequi"

        payload = {"phone_number": phone_number}

        try:
            response = requests.post(
                url,
                json=payload,
                headers=self._headers(),
                timeout=self.REQUEST_TIMEOUT,
            )
            response.raise_for_status()
            return response.json()
        except requests.RequestException as exc:
            logger.exception("Error al tokenizar Nequi: %s", exc)
            raise
```

#### **1.3. Implementar Bancolombia Transfer**

```python
class WompiPaymentClient:
    # ... m√©todos existentes ...

    def create_bancolombia_transfer_transaction(
        self,
        *,
        amount_in_cents: int,
        reference: str,
        customer_email: str,
        payment_description: str,  # Max 64 caracteres
        redirect_url: str | None = None,
    ):
        """
        Crea una transacci√≥n Bancolombia Transfer (Bot√≥n Bancolombia).

        Args:
            amount_in_cents: Monto en centavos
            reference: Referencia √∫nica de pago
            customer_email: Email del pagador
            payment_description: Descripci√≥n del pago (max 64 caracteres)
            redirect_url: URL de redirecci√≥n opcional

        Returns:
            (dict, int): Response data y status code

        Note:
            La respuesta incluir√° async_payment_url donde el usuario
            debe autenticarse con Bancolombia.
        """
        if len(payment_description) > 64:
            raise ValueError("payment_description debe tener m√°ximo 64 caracteres")

        currency = getattr(settings, "WOMPI_CURRENCY", "COP")

        signature = build_integrity_signature(
            reference=reference,
            amount_in_cents=amount_in_cents,
            currency=currency,
        )

        payload = {
            "amount_in_cents": amount_in_cents,
            "currency": currency,
            "customer_email": customer_email,
            "reference": reference,
            "payment_method": {
                "type": "BANCOLOMBIA_TRANSFER",
                "payment_description": payment_description,
            },
        }

        if signature:
            payload["signature"] = {"integrity": signature}

        if redirect_url:
            payload["redirect_url"] = redirect_url

        return self.create_transaction(payload)
```

#### **1.4. Implementar Daviplata**

```python
class WompiPaymentClient:
    # ... m√©todos existentes ...

    def create_daviplata_transaction(
        self,
        *,
        amount_in_cents: int,
        reference: str,
        customer_email: str,
        phone_number: str,
        redirect_url: str | None = None,
    ):
        """
        Crea una transacci√≥n Daviplata.

        Args:
            amount_in_cents: Monto en centavos
            reference: Referencia √∫nica de pago
            customer_email: Email del pagador
            phone_number: N√∫mero de celular Daviplata (10 d√≠gitos)
            redirect_url: URL de redirecci√≥n opcional

        Returns:
            (dict, int): Response data y status code

        Example (Sandbox):
            phone_number="3991111111"  # APPROVED
            OTP: 574829 ‚Üí APPROVED
            OTP: 932015 ‚Üí DECLINED
            OTP: 186743 ‚Üí DECLINED sin saldo
            OTP: 999999 ‚Üí ERROR
        """
        currency = getattr(settings, "WOMPI_CURRENCY", "COP")

        signature = build_integrity_signature(
            reference=reference,
            amount_in_cents=amount_in_cents,
            currency=currency,
        )

        payload = {
            "amount_in_cents": amount_in_cents,
            "currency": currency,
            "customer_email": customer_email,
            "reference": reference,
            "payment_method": {
                "type": "DAVIPLATA",
                "phone_number": phone_number,
            },
        }

        if signature:
            payload["signature"] = {"integrity": signature}

        if redirect_url:
            payload["redirect_url"] = redirect_url

        return self.create_transaction(payload)
```

#### **1.5. Implementar Tokenizaci√≥n de Tarjetas**

```python
class WompiPaymentClient:
    # ... m√©todos existentes ...

    def tokenize_card(
        self,
        *,
        number: str,
        cvc: str,
        exp_month: str,
        exp_year: str,
        card_holder: str,
    ):
        """
        Tokeniza una tarjeta de cr√©dito para cobros recurrentes.

        Args:
            number: N√∫mero de tarjeta (sin espacios)
            cvc: C√≥digo de seguridad (3 d√≠gitos)
            exp_month: Mes de expiraci√≥n (01-12)
            exp_year: A√±o de expiraci√≥n (YY o YYYY)
            card_holder: Nombre del titular

        Returns:
            dict: Token de tarjeta

        Example (Sandbox):
            number="4242424242424242"  # APPROVED
            number="4111111111111111"  # DECLINED

        Response:
            {
                "status": "CREATED",
                "data": {
                    "id": "tok_prod_123456_abcdef",
                    "created_at": "2023-06-09T20:28:50.000Z",
                    "brand": "VISA",
                    "name": "VISA-4242",
                    "last_four": "4242",
                    "bin": "424242",
                    "exp_year": "25",
                    "exp_month": "12",
                    "card_holder": "Juan Perez"
                }
            }
        """
        if not self.base_url:
            raise ValueError("WOMPI_BASE_URL no configurada")

        url = f"{self.base_url.rstrip('/')}/tokens/cards"

        payload = {
            "number": number.replace(" ", ""),  # Remover espacios
            "cvc": cvc,
            "exp_month": exp_month.zfill(2),  # Asegurar 2 d√≠gitos
            "exp_year": exp_year,
            "card_holder": card_holder,
        }

        # Tokenizaci√≥n usa llave p√∫blica, no privada
        public_key = getattr(settings, "WOMPI_PUBLIC_KEY", "")
        headers = {"Content-Type": "application/json"}
        if public_key:
            headers["Authorization"] = f"Bearer {public_key}"

        try:
            response = requests.post(
                url,
                json=payload,
                headers=headers,
                timeout=self.REQUEST_TIMEOUT,
            )
            response.raise_for_status()
            return response.json()
        except requests.RequestException as exc:
            logger.exception("Error al tokenizar tarjeta: %s", exc)
            raise
```

### **Fase 2: Centralizar Marketplace** üü°

**Objetivo:** Eliminar duplicaci√≥n de c√≥digo en marketplace/views.py

**Archivos a modificar:**
- [marketplace/views.py](marketplace/views.py) (l√≠neas 248-286)

**Cambios requeridos:**

```python
# ANTES (marketplace/views.py:248-286)
base_url = getattr(settings, "WOMPI_BASE_URL", PaymentService.WOMPI_DEFAULT_BASE_URL)
try:
    acceptance_token = PaymentService._resolve_acceptance_token(base_url)
except requests.Timeout:
    logger.error("Timeout al obtener acceptance token de Wompi")
    # ... manejo duplicado

signature = PaymentService._build_integrity_signature(
    reference=reference,
    amount_in_cents=amount_in_cents,
    currency=getattr(settings, "WOMPI_CURRENCY", "COP"),
)

# DESPU√âS
from finances.gateway import WompiPaymentClient, build_integrity_signature

# Usar gateway centralizado
acceptance_token = WompiPaymentClient.resolve_acceptance_token()

# Usar funci√≥n centralizada de firma
signature = build_integrity_signature(
    reference=reference,
    amount_in_cents=amount_in_cents,
    currency=getattr(settings, "WOMPI_CURRENCY", "COP"),
)

# Manejo de errores centralizado
if not acceptance_token:
    logger.error("No se pudo obtener acceptance token de Wompi")
    return Response(
        {"error": "Payment gateway temporarily unavailable"},
        status=status.HTTP_503_SERVICE_UNAVAILABLE
    )
```

**Beneficios:**
- ‚úÖ Elimina duplicaci√≥n de l√≥gica
- ‚úÖ Centraliza manejo de errores
- ‚úÖ Usa circuit breaker del gateway
- ‚úÖ Reduce l√≠neas de c√≥digo

### **Fase 3: Corregir Validaci√≥n de Webhooks** üü°

**Objetivo:** Implementar algoritmo oficial de Wompi para validaci√≥n de firmas

**Archivo:** [spa/services/payments.py:64-87](spa/services/payments.py:64-87)

**Implementaci√≥n correcta seg√∫n documentaci√≥n:**

```python
def _validate_signature(self):
    """
    Valida la firma del evento seg√∫n el algoritmo oficial de Wompi.

    Algoritmo:
    1. Extraer properties del signature object
    2. Obtener valores de data seg√∫n properties
    3. Concatenar valores + timestamp + secret
    4. SHA256 y comparar con checksum
    """
    # Validar datos requeridos
    if not all([self.data, self.timestamp]):
        logger.error("[PAYMENT-ALERT] Webhook Error: Datos incompletos")
        raise ValueError("Datos del webhook incompletos.")

    signature_obj = self.request_body.get("signature", {})
    properties = signature_obj.get("properties", [])
    sent_checksum = signature_obj.get("checksum")

    if not sent_checksum or not properties:
        logger.error("[PAYMENT-ALERT] Webhook Error: Firma o properties ausentes")
        raise ValueError("Firma del webhook incompleta.")

    # Paso 1: Concatenar valores seg√∫n properties
    values = []
    for prop_path in properties:
        # Ej: "transaction.id" -> data["transaction"]["id"]
        keys = prop_path.split(".")
        value = self.data

        for key in keys:
            if isinstance(value, dict):
                value = value.get(key, "")
            else:
                value = ""
                break

        values.append(str(value))

    concatenated = "".join(values)

    # Paso 2: Agregar timestamp
    concatenated += str(self.timestamp)

    # Paso 3: Agregar secreto de eventos
    event_secret = getattr(settings, "WOMPI_EVENT_SECRET", "")
    if not event_secret:
        logger.error("[PAYMENT-ALERT] WOMPI_EVENT_SECRET no configurado")
        raise ValueError("WOMPI_EVENT_SECRET no est√° configurado.")

    concatenated += event_secret

    # Paso 4: Calcular SHA256
    calculated_checksum = hashlib.sha256(concatenated.encode('utf-8')).hexdigest()

    # Paso 5: Comparar checksums
    if calculated_checksum.upper() != sent_checksum.upper():
        logger.error(
            "[PAYMENT-ALERT] Webhook Error: Firma inv√°lida. "
            "Calculado: %s, Recibido: %s",
            calculated_checksum,
            sent_checksum
        )
        raise ValueError("Firma del webhook inv√°lida. La petici√≥n podr√≠a ser fraudulenta.")

    logger.info("[PAYMENT-SUCCESS] Webhook validado correctamente")
```

**Ejemplo de validaci√≥n:**

```python
# Webhook recibido
webhook = {
    "event": "transaction.updated",
    "data": {
        "transaction": {
            "id": "1234-1610641025-49201",
            "status": "APPROVED",
            "amount_in_cents": 4490000
        }
    },
    "signature": {
        "properties": [
            "transaction.id",
            "transaction.status",
            "transaction.amount_in_cents"
        ],
        "checksum": "3476DDA50F64CD7CBD160689640506FEBEA93239BC524FC0469B2C68A3CC8BD0"
    },
    "timestamp": 1530291411
}

# Validaci√≥n
# Paso 1: Concatenar valores
values = ["1234-1610641025-49201", "APPROVED", "4490000"]
concatenated = "1234-1610641025-49201APPROVED4490000"

# Paso 2: Agregar timestamp
concatenated += "1530291411"
# "1234-1610641025-49201APPROVED44900001530291411"

# Paso 3: Agregar secret
concatenated += "prod_events_OcHnIzeBl5socpwByQ4hA52Em3USQ93Z"
# "1234-1610641025-49201APPROVED44900001530291411prod_events_OcHnIzeBl5socpwByQ4hA52Em3USQ93Z"

# Paso 4: SHA256
checksum = hashlib.sha256(concatenated.encode()).hexdigest()
# "3476DDA50F64CD7CBD160689640506FEBEA93239BC524FC0469B2C68A3CC8BD0"

# ‚úÖ Coincide con signature.checksum
```

**Nota importante de la documentaci√≥n:**
> "Los `properties` pueden variar en el tiempo y en cada evento, por eso es muy importante que no los asumas como un arreglo fijo dentro de tu c√≥digo, sino que siempre los extraigas del evento y utilices apropiadamente en cada validaci√≥n."

### **Fase 4: Agregar Par√°metros Faltantes** üü¢

#### **4.1. Agregar Soporte para Expiration Time**

**Archivo:** [finances/gateway.py:82-91](finances/gateway.py:82-91)

```python
def build_integrity_signature(
    reference: str,
    amount_in_cents: int,
    currency: str,
    expiration_time: str | None = None
) -> str | None:
    """
    Genera la firma de integridad para Wompi con soporte para expiration_time.

    SHA256("<reference><amount_in_cents><currency>[<expiration_time>]<INTEGRITY_KEY>")

    Args:
        reference: Referencia √∫nica del pago
        amount_in_cents: Monto en centavos
        currency: Moneda (ej: "COP")
        expiration_time: Fecha/hora de expiraci√≥n en formato ISO8601 UTC (opcional)
                        Ej: "2023-06-09T20:28:50.000Z"

    Returns:
        str: Hash SHA256 hexadecimal o None si falta WOMPI_INTEGRITY_KEY

    Example:
        # Sin expiration_time
        build_integrity_signature("REF-123", 2490000, "COP")
        # Concatena: "REF-1232490000COPtest_integrity_..."

        # Con expiration_time
        build_integrity_signature("REF-123", 2490000, "COP", "2023-06-09T20:28:50.000Z")
        # Concatena: "REF-1232490000COP2023-06-09T20:28:50.000Ztest_integrity_..."
    """
    integrity_key = getattr(settings, "WOMPI_INTEGRITY_KEY", None)
    if not integrity_key:
        logger.warning("WOMPI_INTEGRITY_KEY no configurada, no se puede generar firma")
        return None

    # Concatenar seg√∫n documentaci√≥n Wompi
    if expiration_time:
        concatenated = f"{reference}{amount_in_cents}{currency}{expiration_time}{integrity_key}"
    else:
        concatenated = f"{reference}{amount_in_cents}{currency}{integrity_key}"

    return hashlib.sha256(concatenated.encode("utf-8")).hexdigest()
```

#### **4.2. Agregar Customer Data y Tax Information al Modelo**

**Archivo:** [spa/models/payment.py](spa/models/payment.py)

**Opci√≥n 1: Campos adicionales (m√°s normalizado)**
```python
class Payment(BaseModel):
    # ... campos existentes ...

    # Customer Data
    customer_legal_id = models.CharField(
        max_length=50,
        blank=True,
        default="",
        help_text="Documento de identidad del pagador"
    )
    customer_legal_id_type = models.CharField(
        max_length=10,
        blank=True,
        default="",
        choices=[
            ("CC", "C√©dula de Ciudadan√≠a"),
            ("CE", "C√©dula de Extranjer√≠a"),
            ("NIT", "N√∫mero de Identificaci√≥n Tributaria"),
            ("PP", "Pasaporte"),
            ("TI", "Tarjeta de Identidad"),
            ("DNI", "Documento Nacional de Identidad"),
            ("RG", "Carteira de Identidade / Registro Geral"),
            ("OTHER", "Otro"),
        ],
        help_text="Tipo de documento del pagador"
    )

    # Tax Information
    tax_vat_in_cents = models.PositiveIntegerField(
        null=True,
        blank=True,
        help_text="IVA en centavos (incluido en amount, no se suma)"
    )
    tax_consumption_in_cents = models.PositiveIntegerField(
        null=True,
        blank=True,
        help_text="Impuesto al consumo en centavos (incluido en amount)"
    )

    # Payment Method Info
    payment_method_type = models.CharField(
        max_length=30,
        blank=True,
        default="",
        choices=[
            ("CARD", "Tarjeta de Cr√©dito/D√©bito"),
            ("PSE", "PSE"),
            ("NEQUI", "Nequi"),
            ("BANCOLOMBIA_TRANSFER", "Bot√≥n Bancolombia"),
            ("BANCOLOMBIA_QR", "QR Bancolombia"),
            ("DAVIPLATA", "Daviplata"),
            ("BNPL", "Buy Now Pay Later"),
            ("PCOL", "Puntos Colombia"),
        ],
        help_text="M√©todo de pago utilizado en Wompi"
    )
    payment_method_data = models.JSONField(
        default=dict,
        blank=True,
        help_text="Datos adicionales del m√©todo de pago (ej: financial_institution_code para PSE)"
    )
```

**Opci√≥n 2: JSON Field (m√°s flexible)**
```python
class Payment(BaseModel):
    # ... campos existentes ...

    wompi_metadata = models.JSONField(
        default=dict,
        blank=True,
        help_text="Metadata adicional de Wompi: customer_data, taxes, payment_method"
    )

    # Ejemplo de estructura:
    # {
    #     "customer_data": {
    #         "legal_id": "123456789",
    #         "legal_id_type": "CC"
    #     },
    #     "taxes": {
    #         "vat_in_cents": 19000,
    #         "consumption_in_cents": 8000
    #     },
    #     "payment_method": {
    #         "type": "PSE",
    #         "financial_institution_code": "1",
    #         "user_type": 0
    #     }
    # }
```

**Recomendaci√≥n:** Opci√≥n 1 para campos cr√≠ticos (customer_legal_id, payment_method_type) + Opci√≥n 2 para datos adicionales

#### **4.3. Actualizar WompiPaymentClient para Aceptar Par√°metros Adicionales**

```python
class WompiPaymentClient:
    # ... m√©todos existentes ...

    def create_transaction(
        self,
        payload: dict,
        *,
        customer_data: dict | None = None,
        shipping_address: dict | None = None,
        taxes: dict | None = None,
        expiration_time: str | None = None,
    ):
        """
        Crea una transacci√≥n en Wompi con par√°metros opcionales extendidos.

        Args:
            payload: Payload base con amount, reference, etc.
            customer_data: Informaci√≥n del pagador {email, full_name, phone_number, legal_id, legal_id_type}
            shipping_address: Direcci√≥n de env√≠o {address_line_1, city, country, phone_number, region}
            taxes: Impuestos {vat: int, consumption: int} en centavos
            expiration_time: Fecha de expiraci√≥n en formato ISO8601 UTC

        Returns:
            (dict, int): Response data y status code
        """
        # Agregar customer_data si se proporciona
        if customer_data:
            payload["customer_data"] = {
                k: v for k, v in customer_data.items() if v is not None
            }

        # Agregar shipping_address si se proporciona
        if shipping_address:
            payload["shipping_address"] = {
                k: v for k, v in shipping_address.items() if v is not None
            }

        # Agregar taxes si se proporciona
        if taxes:
            tax_payload = {}
            if taxes.get("vat"):
                tax_payload["vat"] = taxes["vat"]
            if taxes.get("consumption"):
                tax_payload["consumption"] = taxes["consumption"]
            if tax_payload:
                payload["tax_in_cents"] = tax_payload

        # Agregar expiration_time si se proporciona
        if expiration_time:
            payload["expiration_time"] = expiration_time

            # Si hay expiration_time, regenerar signature con el tiempo incluido
            if "signature" in payload and "integrity" in payload["signature"]:
                reference = payload.get("reference")
                amount = payload.get("amount_in_cents")
                currency = payload.get("currency")

                if reference and amount and currency:
                    new_signature = build_integrity_signature(
                        reference=reference,
                        amount_in_cents=amount,
                        currency=currency,
                        expiration_time=expiration_time,
                    )
                    if new_signature:
                        payload["signature"]["integrity"] = new_signature

        # Usar m√©todo base
        return super().create_transaction(payload)
```

### **Fase 5: Mover Webhook Handler a Finances** üü¢

**Objetivo:** Verdadera centralizaci√≥n moviendo WompiWebhookService a finances

**Cambios:**

1. **Crear [finances/webhooks.py](finances/webhooks.py):**
```python
import hashlib
import json
import logging

from django.conf import settings
from django.db import transaction

from spa.models import WebhookEvent

logger = logging.getLogger(__name__)


class WompiWebhookService:
    """
    Servicio centralizado para procesar webhooks de Wompi.
    Maneja validaci√≥n de firma y procesamiento de eventos.
    """

    SUPPORTED_EVENTS = [
        "transaction.updated",
        "nequi_token.updated",
        "bancolombia_transfer_token.updated",
    ]

    def __init__(self, request_data, headers=None):
        if isinstance(request_data, dict):
            self.request_body = request_data
        else:
            try:
                self.request_body = dict(request_data)
            except Exception:
                self.request_body = {}

        self.data = self.request_body.get("data", {})
        self.event_type = self.request_body.get("event")
        self.timestamp = self.request_body.get("timestamp")
        self.headers = headers or {}

        # Crear registro de webhook
        self.event_record = WebhookEvent.objects.create(
            payload=self.request_body,
            headers=dict(self.headers),
            event_type=self.event_type or "",
            status=WebhookEvent.Status.PROCESSED,
        )

    def _validate_signature(self):
        """
        Valida la firma del evento seg√∫n el algoritmo oficial de Wompi.
        """
        # ... implementaci√≥n de Fase 3 ...

    def _update_event_status(self, status, error_message=None):
        """Actualiza el estado del registro de webhook."""
        self.event_record.status = status
        self.event_record.error_message = error_message or ""
        self.event_record.save(update_fields=['status', 'error_message', 'updated_at'])

    def process_event(self):
        """
        Procesa el webhook seg√∫n su tipo.

        Returns:
            dict: Resultado del procesamiento
        """
        try:
            # Validar firma
            self._validate_signature()

            # Procesar seg√∫n tipo de evento
            if self.event_type == "transaction.updated":
                return self._process_transaction_updated()
            elif self.event_type == "nequi_token.updated":
                return self._process_nequi_token_updated()
            elif self.event_type == "bancolombia_transfer_token.updated":
                return self._process_bancolombia_token_updated()
            else:
                logger.warning(
                    "Tipo de evento no soportado: %s",
                    self.event_type
                )
                self._update_event_status(
                    WebhookEvent.Status.IGNORED,
                    f"Tipo de evento no soportado: {self.event_type}"
                )
                return {"status": "ignored", "reason": "unsupported_event_type"}

        except ValueError as exc:
            self._update_event_status(WebhookEvent.Status.FAILED, str(exc))
            logger.error("[PAYMENT-ALERT] Webhook validation failed: %s", exc)
            raise
        except Exception as exc:
            self._update_event_status(WebhookEvent.Status.FAILED, str(exc))
            logger.exception("[PAYMENT-ALERT] Webhook processing failed: %s", exc)
            raise

    def _process_transaction_updated(self):
        """
        Procesa evento transaction.updated.
        NOTA: Esta l√≥gica deber√≠a eventualmente moverse aqu√≠ desde spa.services
        """
        # Por ahora, delegar a la implementaci√≥n existente
        from spa.services.payments import WompiWebhookService as SpaWebhookService

        spa_service = SpaWebhookService(self.request_body, self.headers)
        return spa_service.process_transaction_update()

    def _process_nequi_token_updated(self):
        """Procesa evento de token Nequi actualizado."""
        # TODO: Implementar
        pass

    def _process_bancolombia_token_updated(self):
        """Procesa evento de token Bancolombia actualizado."""
        # TODO: Implementar
        pass
```

2. **Actualizar [spa/views/webhook_view.py](spa/views/webhook_view.py):**
```python
# ANTES
from spa.services.payments import WompiWebhookService

# DESPU√âS
from finances.webhooks import WompiWebhookService
```

---

## üìä RESUMEN EJECUTIVO

### **Estado Actual vs Documentaci√≥n Wompi:**

| Aspecto | Implementado | Faltante | Prioridad | Esfuerzo Estimado |
|---------|--------------|----------|-----------|-------------------|
| **Gateway Centralizado** | ‚úÖ 90% | Circuit breaker en disbursement mejorado | üü¢ Baja | 2 horas |
| **M√©todos de Pago** | üî¥ 20% | PSE, Nequi, Bancolombia, Daviplata, etc. | üî¥ **CR√çTICA** | 2-3 d√≠as |
| **Tokenizaci√≥n** | ‚ùå 0% | POST /tokens/cards, POST /tokens/nequi | üî¥ **CR√çTICA** | 1 d√≠a |
| **Webhooks** | üü° 70% | Algoritmo de firma oficial, centralizaci√≥n | üü° Media | 4-6 horas |
| **Par√°metros** | üü° 60% | customer_data, taxes, payment_method, expiration_time | üü¢ Baja | 1 d√≠a |
| **Centralizaci√≥n** | üü° 70% | Eliminar duplicados en marketplace, mover webhooks | üü° Media | 4 horas |
| **PSE Institutions** | ‚ùå 0% | GET /pse/financial_institutions | üü° Media | 2 horas |
| **Async Payments** | ‚ùå 0% | Manejo de async_payment_url | üü¢ Baja | 3-4 horas |

### **Matriz de Priorizaci√≥n:**

```
CR√çTICO (Hacer YA) üî¥
‚îú‚îÄ‚îÄ PSE Implementation (Colombia usa mayormente PSE)
‚îú‚îÄ‚îÄ Nequi Implementation (segundo m√©todo m√°s popular)
‚îî‚îÄ‚îÄ Tokenizaci√≥n de Tarjetas (para cobros recurrentes robustos)

ALTA (Pr√≥xima Semana) üü°
‚îú‚îÄ‚îÄ Corregir validaci√≥n de webhooks
‚îú‚îÄ‚îÄ Centralizar marketplace
‚îî‚îÄ‚îÄ Daviplata Implementation

MEDIA (Pr√≥ximo Sprint) üü¢
‚îú‚îÄ‚îÄ Bancolombia Transfer
‚îú‚îÄ‚îÄ Customer Data y Taxes
‚îú‚îÄ‚îÄ PSE Financial Institutions
‚îî‚îÄ‚îÄ Async Payment URLs

BAJA (Backlog) ‚ö™
‚îú‚îÄ‚îÄ Bancolombia QR
‚îú‚îÄ‚îÄ BNPL
‚îú‚îÄ‚îÄ Puntos Colombia
‚îî‚îÄ‚îÄ Webhook Handler en finances module
```

### **Recomendaci√≥n Final:**

**Tu m√≥dulo `finances` tiene una base arquitect√≥nica s√≥lida y bien dise√±ada**, con:
- ‚úÖ Gateway centralizado con 3 clientes especializados
- ‚úÖ Circuit breakers implementados
- ‚úÖ Manejo de errores robusto
- ‚úÖ Firma de integridad correcta
- ‚úÖ Sistema de comisiones funcional

**PERO le faltan las implementaciones espec√≠ficas de m√©todos de pago de Wompi**.

Actualmente el gateway solo se usa para:
- ‚úÖ Consultar transacciones existentes
- ‚úÖ Cobros recurrentes VIP gen√©ricos
- ‚úÖ Dispersi√≥n de comisiones al desarrollador

**Para cumplir 100% con la documentaci√≥n de Wompi y ofrecer todos los m√©todos de pago a tus usuarios, necesitas:**

1. üî¥ **URGENTE - Implementar PSE**
   - Es el m√©todo de pago m√°s usado en Colombia (transferencias bancarias)
   - Sin esto, muchos usuarios no podr√°n pagar
   - Esfuerzo: ~8 horas

2. üî¥ **URGENTE - Implementar Nequi**
   - Segundo m√©todo m√°s popular
   - Muy usado por usuarios j√≥venes
   - Esfuerzo: ~6 horas

3. üî¥ **URGENTE - Tokenizaci√≥n de Tarjetas**
   - Necesario para cobros recurrentes robustos
   - Mejora experiencia VIP
   - Esfuerzo: ~4 horas

4. üü° **IMPORTANTE - Corregir validaci√≥n de webhooks**
   - Seguridad cr√≠tica
   - Evita rechazar webhooks leg√≠timos
   - Esfuerzo: ~4 horas

5. üü° **IMPORTANTE - Centralizar marketplace**
   - Elimina duplicaci√≥n
   - Mejora mantenibilidad
   - Esfuerzo: ~3 horas

6. üü¢ **RECOMENDADO - Agregar customer_data y taxes**
   - Cumplimiento fiscal
   - Mejor trazabilidad
   - Esfuerzo: ~6 horas

**Total Esfuerzo Cr√≠tico:** ~18 horas (2-3 d√≠as de desarrollo)
**Total Esfuerzo Completo:** ~31 horas (4-5 d√≠as de desarrollo)

---

## üìÅ ARCHIVOS PRINCIPALES ANALIZADOS

1. **finances/gateway.py** (191 l√≠neas)
   - WompiGateway (consultas)
   - WompiPaymentClient (creaci√≥n de transacciones)
   - build_integrity_signature()

2. **finances/services.py** (341 l√≠neas)
   - WompiDisbursementClient (dispersi√≥n)
   - DeveloperCommissionService (comisiones)

3. **finances/models.py** (74 l√≠neas)
   - CommissionLedger (con validaciones actualizadas)

4. **spa/services/payments.py** (740 l√≠neas)
   - WompiWebhookService (procesamiento de webhooks)
   - PaymentService (l√≥gica de negocio de pagos)

5. **spa/models/payment.py** (212 l√≠neas)
   - Payment (modelo principal)
   - ClientCredit (saldo a favor)
   - WebhookEvent (registro de webhooks)

6. **marketplace/views.py** (l√≠neas 248-286)
   - Duplicaci√≥n de l√≥gica Wompi

7. **env.example.txt** (l√≠neas 99-112)
   - Configuraci√≥n de variables Wompi

8. **zenzspa/settings/base.py** (l√≠neas 401-425)
   - Configuraci√≥n centralizada Wompi

---

## üîó ENLACES √öTILES

- **Documentaci√≥n Oficial Wompi:** https://docs.wompi.co/
- **Swagger API Wompi:** https://production.wompi.co/v1
- **Dashboard Comercios Wompi:** https://comercios.wompi.co
- **Sandbox Wompi:** https://sandbox.wompi.co/v1
- **Widget Wompi:** https://checkout.wompi.co/widget.js

---

**Fecha de An√°lisis:** 2025-11-26
**Analista:** Claude (Anthropic)
**Versi√≥n del Documento:** 1.0
